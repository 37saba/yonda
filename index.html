<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>yonda?β</title>
<style>
  :root{ --toolbar-bg:#f5f5f7; --btn-bg:#0b76d1; --btn-active:#ff6f00; }
  html,body{height:100%;margin:0;font-family:system-ui,"Yu Gothic",sans-serif}
  .toolbar{background:var(--toolbar-bg);padding:8px;display:flex;gap:8px;align-items:center;border-bottom:1px solid #ddd;flex-wrap:wrap;z-index:3000}
  .toolbar label{display:flex;align-items:center;gap:6px;font-size:14px}
  button{padding:8px 12px;border-radius:6px;border:0;background:var(--btn-bg);color:#fff;cursor:pointer}
  button.active{background:var(--btn-active)}
  input[type=color]{width:36px;height:28px;border:0;background:transparent;cursor:pointer}
  input[type=number]{width:64px}
  .app{display:flex;flex-direction:column;height:calc(100% - 56px)}
  .canvas-wrap{flex:1;position:relative;overflow:hidden;background:#fff}
  canvas{position:absolute;left:0;top:0;width:100%;height:100%;touch-action:none;z-index:1;background:transparent}
  .text-overlay{position:absolute;inset:0;padding:20px;box-sizing:border-box;writing-mode:vertical-rl;text-orientation:upright;overflow:auto;z-index:20;pointer-events:none}
  .text-overlay .paper{background:transparent;color:#222}
  .sticky{position:absolute;z-index:30;display:flex;flex-direction:column;border-radius:8px;box-shadow:0 6px 14px rgba(0,0,0,0.12);min-width:120px;min-height:80px;overflow:hidden;background:#fff475;user-select:none;cursor:grab}
  .sticky.selected{outline:3px solid rgba(0,120,215,0.5)}
  .sticky-header{display:flex;justify-content:flex-end;align-items:center;gap:6px;padding:6px 8px;background:transparent}
  .sticky-controls button{color:black;font-weight:bold;-webkit-text-stroke:1px white;background:rgba(255,255,255,0.75);border:1px solid rgba(0,0,0,0.12);border-radius:4px;padding:2px 6px;cursor:pointer}
  .sticky-content{padding:8px;font-size:14px;background:transparent;flex:1;overflow:auto;outline:none;min-height:40px;color:#000}
  .resize-handle{position:absolute;right:6px;bottom:6px;width:16px;height:16px;border-radius:3px;background:rgba(0,0,0,0.15);cursor:se-resize;z-index:60}
  .hidden{opacity:0;pointer-events:none}
  @media(max-width:700px){.text-overlay{width:40%}}
  /* minimized */
  .sticky.minimized { width: 6px !important; min-width:6px !important; padding:0 !important; border-radius:3px; background: var(--sticky-color,#ccc) !important; overflow:hidden !important; cursor:pointer; pointer-events:auto !important; }
  .sticky.minimized textarea, .sticky.minimized .sticky-header, .sticky.minimized .sticky-color-picker, .sticky.minimized .sticky-delete { display:none !important; pointer-events:none !important; }
  /* hide-memos: hide both canvas strokes and stickies when toggled */
  .hide-memos canvas { opacity: 0 !important; pointer-events: none !important; }
  .hide-memos .sticky { opacity: 0 !important; pointer-events: none !important; }
</style>

<!-- Supabase クライアント読み込み -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<!-- Supabase の URL/ANON は任意の方法で設定済み（別ファイルでもOK） -->
<script>
  window.SUPABASE_URL = "https://pphwdbxacalkjobjdmhf.supabase.co";
  window.SUPABASE_ANON = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBwaHdkYnhhY2Fsa2pvYmpkbWhmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ5NTc3MDUsImV4cCI6MjA4MDUzMzcwNX0.OF6fzndDhtmrjUn_o9Jg5Fne9eHwSnWzfFT49_Iv6h0";
</script>
</head>
<body>

<div class="toolbar">
  <button id="penBtn" class="active"> ペン</button>
  <button id="eraserBtn"> 消しゴム</button>

  <label>色: <input type="color" id="penColor" value="#222222"></label>
  <label>太さ: <input id="penSize" type="range" min="1" max="40" value="5"></label>
  <label><input id="sizeNumber" type="number" min="1" max="80" value="5" /> px</label>

  <div style="width:1px;background:#ddd;height:28px;margin:0 8px"></div>

  <label>ふせん色: <input type="color" id="stickyBgColor" value="#fff475"></label>
  <label>文字色: <input type="color" id="stickyTextColor" value="#000000"></label>
  <label>初期: <select id="stickyInitSize"><option value="140">小</option><option value="180" selected>中</option><option value="240">大</option></select></label>
  <button id="addStickyBtn"> ふせん追加</button>

  <div style="flex:1"></div>

  <button id="clearBtn"> 全消去</button>
  <button id="toggleMemoBtn">メモ非表示</button>
</div>

<div class="app">
  <div class="canvas-wrap" id="canvasWrap">
    <canvas id="canvas"></canvas>

    <!-- 文章オーバーレイ（固定文・編集不可） -->
    <div class="text-overlay" id="textOverlay">
      <div class="paper" id="paper" contenteditable="false">
       <h3>吾輩は猫である</h3>
        <p>
         吾輩は猫である。名前はまだ無い。
         <!-- （省略）長文サンプル -->
       </p>
      </div>
    </div>
  </div>
</div>

<script>
/* ---------------------------
   DOM & UI state
----------------------------*/
const canvas = document.getElementById('canvas');
const canvasWrap = document.getElementById('canvasWrap');
const ctx = canvas.getContext('2d');

const penBtn = document.getElementById('penBtn');
const eraserBtn = document.getElementById('eraserBtn');
const penColorInput = document.getElementById('penColor');
const penSizeInput = document.getElementById('penSize');
const sizeNumber = document.getElementById('sizeNumber');

const stickyBgInput = document.getElementById('stickyBgColor');
const stickyTextInput = document.getElementById('stickyTextColor');
const stickyInitSize = document.getElementById('stickyInitSize');
const addStickyBtn = document.getElementById('addStickyBtn');
const toggleMemoBtn = document.getElementById('toggleMemoBtn');
const clearBtn = document.getElementById('clearBtn');

const textOverlay = document.getElementById('textOverlay');
textOverlay.style.pointerEvents = 'none';

let mode = 'pen';
penBtn.addEventListener('click', ()=>{ mode='pen'; penBtn.classList.add('active'); eraserBtn.classList.remove('active'); });
eraserBtn.addEventListener('click', ()=>{ mode='eraser'; eraserBtn.classList.add('active'); penBtn.classList.remove('active'); });

penSizeInput.addEventListener('input', ()=> sizeNumber.value = penSizeInput.value);
sizeNumber.addEventListener('input', ()=>{ const v = Number(sizeNumber.value); if(!isNaN(v) && v>0){ penSizeInput.value = v; } });

/* ---------------------------
   Stroke storage (normalized) & drawing
----------------------------*/
let strokes = [];
window.strokes = strokes; // {id, mode, color, size, segments: [{x1,y1,cx,cy,x2,y2}], time}
const STROKE_LS_KEY = 'memoStrokes_v1';
function uid(){ return Date.now().toString(36) + '-' + Math.random().toString(36).slice(2,8); }
function localSaveStrokes(){ try{ localStorage.setItem(STROKE_LS_KEY, JSON.stringify(strokes)); }catch(e){console.warn(e);} }
function localLoadStrokes(){ try{ const raw = localStorage.getItem(STROKE_LS_KEY); return raw?JSON.parse(raw):[]; }catch(e){ return []; } }

/* canvas sizing & DPR-aware backing buffer */
function resizeCanvas(){
  const rect = canvasWrap.getBoundingClientRect();
  const cssW = Math.max(1, Math.round(rect.width));
  const cssH = Math.max(1, Math.round(rect.height));
  const dpr = window.devicePixelRatio || 1;
  canvas.style.width = cssW + 'px';
  canvas.style.height = cssH + 'px';
  canvas.width = Math.round(cssW * dpr);
  canvas.height = Math.round(cssH * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  redrawAll();
}
window.addEventListener('resize', resizeCanvas);
new ResizeObserver(resizeCanvas).observe(canvasWrap);
resizeCanvas();

/* draw a stroke */
function drawStrokeOnCanvas(stroke){
  if(!stroke || !stroke.segments) return;
  const rect = canvas.getBoundingClientRect();
  const cssW = rect.width, cssH = rect.height;
  ctx.save();
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.lineWidth = (stroke.size || 2);
  if(stroke.mode === 'pen'){ ctx.globalCompositeOperation = 'source-over'; ctx.strokeStyle = stroke.color || '#222'; }
  else { ctx.globalCompositeOperation = 'destination-out'; ctx.strokeStyle = 'rgba(0,0,0,1)'; }
  for(const seg of stroke.segments){
    ctx.beginPath();
    ctx.moveTo(seg.x1 * cssW, seg.y1 * cssH);
    ctx.quadraticCurveTo(seg.cx * cssW, seg.cy * cssH, seg.x2 * cssW, seg.y2 * cssH);
    ctx.stroke();
  }
  ctx.restore();
}

/* simple fallback line */
function drawLine(p1, p2){
  if(!p1 || !p2) return;
  ctx.save();
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.lineWidth = Number(penSizeInput.value) || 2;
  ctx.globalCompositeOperation = (mode === 'pen') ? 'source-over' : 'destination-out';
  ctx.strokeStyle = (mode === 'pen') ? penColorInput.value : 'rgba(0,0,0,1)';
  ctx.beginPath();
  ctx.moveTo(p1.x, p1.y);
  ctx.lineTo(p2.x, p2.y);
  ctx.stroke();
  ctx.restore();
}

function redrawAll(){
  const rect = canvas.getBoundingClientRect();
  const cssW = rect.width, cssH = rect.height;
  ctx.clearRect(0,0,cssW,cssH);
  for(const s of strokes) drawStrokeOnCanvas(s);
}

/* restore local strokes on load */
strokes = localLoadStrokes() || [];
setTimeout(()=> { resizeCanvas(); redrawAll(); }, 20);

/* ---------- drawing input: smooth via midpoint quadratic ---------- */
let isDrawing = false, prevPoint = null, prevMid = null, currentStroke = null;

function getPos(e){
  const r = canvas.getBoundingClientRect();
  const p = (e.touches && e.touches[0]) ? e.touches[0] : e;
  return { x: p.clientX - r.left, y: p.clientY - r.top };
}
function midpoint(a,b){ return { x:(a.x+b.x)/2, y:(a.y+b.y)/2 }; }

function startDraw(e){
  e.preventDefault();
  if(e.pointerId && canvas.setPointerCapture) try{ canvas.setPointerCapture(e.pointerId); }catch(_){}
  isDrawing = true;
  const p = getPos(e);
  prevPoint = p; prevMid = p;
  currentStroke = { id: uid(), mode: mode, color: mode==='pen'?penColorInput.value:null, size: Number(penSizeInput.value), segments: [], time: Date.now() };
}
function moveDraw(e){
  if(!isDrawing || !currentStroke) return;
  const p = getPos(e);
  const mid = midpoint(prevPoint, p);

  // immediate UX draw
  ctx.lineCap = 'round'; ctx.lineJoin = 'round';
  ctx.lineWidth = Number(penSizeInput.value);
  if(mode === 'pen'){ ctx.globalCompositeOperation = 'source-over'; ctx.strokeStyle = penColorInput.value; }
  else { ctx.globalCompositeOperation = 'destination-out'; }
  ctx.beginPath();
  ctx.moveTo(prevMid.x, prevMid.y);
  ctx.quadraticCurveTo(prevPoint.x, prevPoint.y, mid.x, mid.y);
  ctx.stroke();

  // normalized segment
  const rect = canvas.getBoundingClientRect();
  const cssW = rect.width, cssH = rect.height;
  const seg = {
    x1: prevMid.x / cssW,
    y1: prevMid.y / cssH,
    cx: prevPoint.x / cssW,
    cy: prevPoint.y / cssH,
    x2: mid.x / cssW,
    y2: mid.y / cssH
  };
  currentStroke.segments.push(seg);

  prevPoint = p; prevMid = mid;
}
function endDraw(e){
  if(e && e.pointerId && canvas.releasePointerCapture) {
    try{ canvas.releasePointerCapture(e.pointerId); }catch(_){} 
  }
  isDrawing = false;
  if(currentStroke){
    // push locally and persist, then send to Supabase (if available)
    strokes.push(currentStroke);
    localSaveStrokes();
    // NOTE: saveStroke will be defined by the module import below (if supabase.js present).
    if (window.__saveStrokeToRemote) {
      window.__saveStrokeToRemote(currentStroke).catch(err => console.warn('saveStroke remote failed', err));
    }
    currentStroke = null;
  }
  prevPoint = prevMid = null;
}

canvas.addEventListener('pointerdown', startDraw);
canvas.addEventListener('pointermove', moveDraw);
canvas.addEventListener('pointerup', endDraw);
canvas.addEventListener('pointercancel', endDraw);
canvas.addEventListener('pointerleave', endDraw);

let canvasScale = 1;
let offsetX = 0, offsetY = 0;

let lastTouchDist = null;
let lastTouchCenter = null;

canvas.addEventListener('touchstart', e => {
  if(e.touches.length === 2){
    e.preventDefault();
    const t1 = e.touches[0], t2 = e.touches[1];
    lastTouchDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
    lastTouchCenter = { x: (t1.clientX + t2.clientX)/2, y: (t1.clientY + t2.clientY)/2 };
  }
});

canvas.addEventListener('touchmove', e => {
  if(e.touches.length === 2){
    e.preventDefault();
    const t1 = e.touches[0], t2 = e.touches[1];
    const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
    const center = { x: (t1.clientX + t2.clientX)/2, y: (t1.clientY + t2.clientY)/2 };
    
    // ズーム比率
    const scaleChange = dist / lastTouchDist;
    canvasScale *= scaleChange;

    // 平行移動
    offsetX += center.x - lastTouchCenter.x;
    offsetY += center.y - lastTouchCenter.y;

    lastTouchDist = dist;
    lastTouchCenter = center;

    redrawAll(); // ここで ctx.setTransform(canvasScale,0,0,canvasScale,offsetX,offsetY) などを使う
  }
});
function startDraw(e){
  // 一本指のみ描画。二本目以降の指は無視
  if(e.pointerType === 'touch' && !e.isPrimary) return;

  e.preventDefault();
  if(e.pointerId && canvas.setPointerCapture) try{ canvas.setPointerCapture(e.pointerId); }catch(_){}

  isDrawing = true;
  const p = getPos(e);
  prevPoint = p; prevMid = p;
  currentStroke = { id: uid(), mode: mode==='pen'?penColorInput.value:null, size: Number(penSizeInput.value), segments: [], time: Date.now() };
}

function moveDraw(e){
  // 一本指のみ描画
  if(!isDrawing || !currentStroke) return;

  const p = getPos(e);
  const mid = midpoint(prevPoint, p);

  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.lineWidth = Number(penSizeInput.value);
  ctx.globalCompositeOperation = (mode==='pen') ? 'source-over' : 'destination-out';
  ctx.strokeStyle = (mode==='pen') ? penColorInput.value : 'rgba(0,0,0,1)';
  ctx.beginPath();
  ctx.moveTo(prevMid.x, prevMid.y);
  ctx.quadraticCurveTo(prevPoint.x, prevPoint.y, mid.x, mid.y);
  ctx.stroke();

  const rect = canvas.getBoundingClientRect();
  const cssW = rect.width, cssH = rect.height;
  currentStroke.segments.push({
    x1: prevMid.x / cssW,
    y1: prevMid.y / cssH,
    cx: prevPoint.x / cssW,
    cy: prevPoint.y / cssH,
    x2: mid.x / cssW,
    y2: mid.y / cssH
  });

  prevPoint = p;
  prevMid = mid;
}

function endDraw(e){
  // 一本指のみ描画終了。二本指ピンチでは currentStroke を破棄しない
  if(!isDrawing) return;

  isDrawing = false;
  if(currentStroke){
    strokes.push(currentStroke);
    localSaveStrokes();
    if(window.__saveStrokeToRemote){
      window.__saveStrokeToRemote(currentStroke).catch(err => console.warn('saveStroke remote failed', err));
    }
    currentStroke = null;
  }

  prevPoint = prevMid = null;
}

/* ---------------------------
   Sticky (ふせん) system
----------------------------*/
let zCounter = 1000;
function normalizeSavedPosVal(val, axisSize, fallback){
  if(val === undefined || val === null) return fallback || 40;
  if(typeof val === 'number' && val > 0 && val <= 1) return Math.round(val * axisSize);
  const n = Number(val);
  if(!isNaN(n) && n > 0 && n <= 1) return Math.round(n * axisSize);
  return parseInt(n || fallback || 40, 10);
}

/* createSticky enhanced: supports saved.fromSync to avoid double-saving */
function createSticky(saved){
  const fromSync = saved?.fromSync === true; // 
  const s = document.createElement('div');
  const id = saved?.id || crypto.randomUUID();
  s.dataset.stickyId = id;
  s.className = 'sticky';
  s.style.left = (normalizeSavedPosVal(saved?.left, canvasWrap.clientWidth, 40)) + 'px';
  s.style.top  = (normalizeSavedPosVal(saved?.top, canvasWrap.clientHeight, 40)) + 'px';
  s.style.width = (saved?.width ?? Number(stickyInitSize.value)) + 'px';
  s.style.height = (saved?.height ?? Math.floor(Number(stickyInitSize.value) * 0.6)) + 'px';
  s.style.background = saved?.color ?? stickyBgInput.value;
  s.style.color = saved?.textColor ?? stickyTextInput.value;
  s.style.zIndex = ++zCounter;

  const header = document.createElement('div'); header.className = 'sticky-header';
  const controls = document.createElement('div'); controls.className = 'sticky-controls';
  controls.innerHTML = `<button class="minBtn">−</button><button class="closeBtn">×</button>`;
  header.appendChild(controls);
  s.appendChild(header);

  const content = document.createElement('div'); content.className = 'sticky-content';
  content.contentEditable = true;
  content.innerHTML = saved?.text ?? '';
  content.style.color = s.style.color;
  s.appendChild(content);

  const rh = document.createElement('div'); rh.className='resize-handle'; s.appendChild(rh);
  canvasWrap.appendChild(s);

  // sync text edits (if remote available, we will call it from the input handler)
  content.addEventListener('input', ()=> {
    // if remote save function is available, call it
    if (window.__saveStickyToRemote) {
      const stickyData = {
        id: s.dataset.stickyId,
        left: parseInt(s.style.left) || 0,
        top: parseInt(s.style.top) || 0,
        width: parseInt(s.style.width) || s.offsetWidth,
        height: parseInt(s.style.height) || s.offsetHeight,
        color: s.style.background,
        textColor: s.style.color,
        text: content.innerHTML
      };
      window.__saveStickyToRemote(stickyData).catch(err => console.warn('saveSticky failed', err));
    }
  });

  // selection / z
  s.addEventListener('pointerdown', (ev)=> {
    if(ev.target.closest('.sticky-controls')) return;
    ev.stopPropagation();
    document.querySelectorAll('.sticky').forEach(x=>x.classList.remove('selected'));
    s.classList.add('selected'); s.style.zIndex = ++zCounter;
  });

  // drag
  let dragging=false, ox=0, oy=0;
  header.addEventListener('pointerdown', (ev)=>{
    if(ev.target.closest('.sticky-controls')) return;
    ev.preventDefault();
    dragging=true;
    const rect = s.getBoundingClientRect();
    ox = ev.clientX - rect.left; oy = ev.clientY - rect.top;
    header.setPointerCapture && header.setPointerCapture(ev.pointerId);
  });
  document.addEventListener('pointermove', (ev)=>{
    if(!dragging) return;
    s.style.left = (ev.clientX - ox) + 'px';
    s.style.top = (ev.clientY - oy) + 'px';
  });
  document.addEventListener('pointerup', (ev)=>{
    if(dragging){ dragging=false;
      // if remote save exists, update remote
      if (window.__saveStickyToRemote) {
        const stickyData = {
          id: s.dataset.stickyId,
          left: parseInt(s.style.left) || 0,
          top: parseInt(s.style.top) || 0,
          width: parseInt(s.style.width) || s.offsetWidth,
          height: parseInt(s.style.height) || s.offsetHeight,
          color: s.style.background,
          textColor: s.style.color,
          text: s.querySelector('.sticky-content').innerHTML
        };
        window.__saveStickyToRemote(stickyData).catch(err=>console.warn('saveSticky update failed', err));
      }
    }
  });

  // resize
  let resizing=false, startW=0, startH=0, startX=0, startY=0;
  rh.addEventListener('pointerdown', (ev)=>{ ev.preventDefault(); ev.stopPropagation(); resizing=true; startW=s.offsetWidth; startH=s.offsetHeight; startX=ev.clientX; startY=ev.clientY; rh.setPointerCapture && rh.setPointerCapture(ev.pointerId); });
  document.addEventListener('pointermove', (ev)=>{ if(!resizing) return; const dx = ev.clientX - startX; const dy = ev.clientY - startY; s.style.width = Math.max(60, startW + dx) + 'px'; s.style.height = Math.max(30, startH + dy) + 'px'; });
  document.addEventListener('pointerup', (ev)=>{ if(resizing){ resizing=false; if (window.__saveStickyToRemote) { const stickyData = { id: s.dataset.stickyId, left: parseInt(s.style.left)||0, top: parseInt(s.style.top)||0, width: parseInt(s.style.width)||s.offsetWidth, height: parseInt(s.style.height)||s.offsetHeight, color: s.style.background, textColor: s.style.color, text: s.querySelector('.sticky-content').innerHTML }; window.__saveStickyToRemote(stickyData).catch(()=>{}); } } });

  // minimize / close
  controls.querySelector('.minBtn').addEventListener('click', (ev)=>{ ev.stopPropagation(); s.classList.toggle('minimized'); });
  controls.querySelector('.closeBtn').addEventListener('click', (ev)=>{ ev.stopPropagation(); s.remove(); if (window.__deleteStickyRemote) { window.__deleteStickyRemote(s.dataset.stickyId).catch(()=>{}); }});

  return s;
}

/* UI: add sticky */
addStickyBtn.addEventListener('click', ()=>{
  const s = createSticky({});
  // gather stickyData and save remotely if possible
  const stickyData = {
    id: s.dataset.stickyId,
    left: parseInt(s.style.left) || 0,
    top: parseInt(s.style.top) || 0,
    width: parseInt(s.style.width) || s.offsetWidth,
    height: parseInt(s.style.height) || s.offsetHeight,
    color: s.style.background,
    textColor: s.style.color,
    text: s.querySelector('.sticky-content').innerHTML
  };
  if (window.__saveStickyToRemote) {
    window.__saveStickyToRemote(stickyData).catch(err => console.warn('saveSticky failed', err));
  }
});

/* toggle memos: hide both canvas strokes and stickies */
let memoVisible = true;
toggleMemoBtn.addEventListener('click', ()=>{
  memoVisible = !memoVisible;
  canvasWrap.classList.toggle('hide-memos', !memoVisible);
  toggleMemoBtn.textContent = memoVisible ? 'メモ非表示' : 'メモ表示';
});

/* clear */
clearBtn.addEventListener('click', ()=>{
  strokes = []; localSaveStrokes();
  ctx.clearRect(0,0,canvas.width,canvas.height);
  document.querySelectorAll('.sticky').forEach(s=>s.remove());
  // optional: remote delete functions can be added to supabase.js and exposed as window.__clearRemote* if desired
});

/* ---------- load local saved strokes on start ---------- */
window.addEventListener('load', ()=>{
  setTimeout(()=> { resizeCanvas(); redrawAll(); }, 50);
});
</script>

<!-- ========== ここから Supabase 同期の接続（必ず末尾に置く） ========== -->
<script type="module">
/*
  ここで supabase.js から関数を import して購読と送信を行います。
  supabase.js は以下を export していることを前提:
    export async function saveStroke(stroke) { ... }
    export async function saveSticky(sticky) { ... }
    export function onStrokeChange(callback) { ... }      // 変更通知 (row) をコールバックに渡す
    export function onStickyChange(callback) { ... }      // 変更通知 (row) をコールバックに渡す
    export async function deleteSticky(id) { ... }       // (任意) 付箋削除用
  （もし関数名が違う場合は import 部分を調整してください）
*/

import { saveStroke, onStrokeChange, saveSticky, onStickyChange } from "./js/supabase.js";

// expose thin wrappers to the non-module code above
window.__saveStrokeToRemote = async (stroke) => {
  // Ensure segments are stored as JSON in DB (depends on your schema)
  try{
    await saveStroke(stroke);
  }catch(e){
    console.warn('remote saveStroke error', e);
    throw e;
  }
};

window.__saveStickyToRemote = async (sticky) => {
  try{
    await saveSticky(sticky);
  }catch(e){
    console.warn('remote saveSticky error', e);
    throw e;
  }
};

// (optional) if supabase.js exports deleteSticky, expose wrapper (safe fallback if not present)
try{
  // subscribe to strokes from other users
  onStrokeChange((dbRow) => {
    if(!dbRow) return;
    // dbRow should be a stroke-like object (id, segments, mode, color, size, time)
    // avoid duplicates: check by id
    if (!window.strokes.some(s => s.id === dbRow.id)) {
    window.strokes.push(dbRow);
    localSaveStrokes();
    redrawAll();
}

  });
} catch(e){
  console.warn('subscribe strokes failed', e);
}

try{
  // subscribe to stickies from other users
  onStickyChange((dbRow) => {
    if(!dbRow) return;
    const id = dbRow.id || dbRow.id; // adjust if key is different
    if(document.querySelector(`[data-sticky-id="${id}"]`)) {
      // already present; could update fields here if you want
      return;
    }
    // create sticky but mark as fromSync to avoid re-saving
createSticky({
  id: dbRow.id,
  fromSync: true,
  left: dbRow.left,
  top: dbRow.top,
  width: dbRow.width,
  height: dbRow.height,
  color: dbRow.color,
  textColor: dbRow.textColor,
  text: dbRow.text
});

  });
} catch(e){
  console.warn('subscribe stickies failed', e);
}
</script>
<!-- ========== /Supabase同期 ========== -->

<!-- この下に余計なスクリプトは入れないでください -->
</body>
</html>
